Classes sao os tipos mais fundamentais do C#

Uma classe é uma estrutura de dados que combina estado (fields) e ações(methods and other function members) em uma unica unidade.

Uma classe fornece uma definição dinamica para criar instances de classe, tambem conhecidos como OBJECTS.

Uma classe suporta inheritance(herança) e polymorphism, mecanismo onde (derived classes) podem ampliar e se especializar em (base classes)

Novas classes sao criadas usando declarações de class.

Uma declaração de classe inicia com um cabeçalho que especifica os atributos e modificadores de classe, uma base class (se fornecida), e interfaces implementadas pela classe.

O cabeçalho é seguido pelo corpo da classe, onde consiste de uma lista de membros declarados escritos entre os delimitadores { e }.

A seguir o codigo mostra uma declaração simples de uma classe chamada POINT:

public class Point
{
    public int x, y;
    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}

Intancias de classes sao criadas usando o operador NEW, que aloca a memoria para uma nova instancia, chama o construtor que inicializa a instancia, e retorna a referencia da instancia.

O statements a seguir cria dois Points objects e armazenam referencias para os dois objetos em duas variables:

Point p1 = new Point(0, 0);
Point p2 = new Point(10, 20);

A memória ocupada por um objeto é recuperada automaticamente quando o objeto não está mais acessível. Não é necessário nem possível desalocar explicitamente objetos em C#.




Os membros de uma classe, sao membros statics ou membros de instance. 


Static members pertencem as classes

instance member pertencem aos objetos

A lista a seguir fornece uma visao geral dos tipos de membros uma classe contêm.
{
    Constants
    Constant values associated with the class
    
    
    Fields
    Variables of the class
    
    
    Methods
    Computations and actions that can be performed by the class
    
    
    Properties
    Actions associated with reading and writing named properties of the class
    
    Indexers
    Actions associated with indexing instances of the class like an 
    array
    
    
    Events
    Notifications that can be generated by the class
    
    
    Operators
    Conversions and expression operators supported by the class
    
    
    Constructors
    Actions required to initialize instances of the class or the class itself
    
    
    Finalizers
    Actions to perform before instances of the class are permanently discarded
    
    
    Types
    Nested types declared by the class
}


Cada membro de classe tem uma acessibilidade associada, que controla as regioes do programa de texto que podem acessar o membro.

Existem seis possiveis formas de acessibilidade.

Os modificadores de acesso são resumidos abaixo

{
    public
    Access isn't limited.

    protected
    Access is limited to this class or classes derived from this class.
    
    
    internal
    Access is limited to the current assembly (.exe, .dll, and so on.).
   
   
    protected internal
    Access is limited to the containing class, classes derived from the containing class, or classes within the same assembly.
    
    
    private
    Access is limited to this class.
   
   
    private protected
    Access is limited to the containing class or classes derived from the containing type within the same assembly.
}

Conforme mostrado no exemplo anterior, os campos somente leitura podem ser declarados com um modificador readonly. A atribuição a um campo readonly só pode ocorrer como parte da declaração do campo ou em um construtor na mesma classe.


------------------------------------------------------***********------

VIRTUAL, OVERRIDE AND ABSTRACT METHODS

Quando um method de instancia declarado inclui o modificador VIRTUAL, o metodo é considerado um metodo virtual. Quando nenhum modificador virtual estiver presente, o método será um método não virtual.

Quando um metodo VIRTUAL é invocado, o tipo de Run-Time(tempo de execução) da instância para a qual a chamada ocorre determina a implementação real do método a ser chamada. 
Em uma invocação de método NONVIRTUAL, o tipo de compile-Time(tempo de compilação) da instância é o fator determinante.

Um método virtual pode ser overriden em uma classe derivada.

Enquanto uma declaração de método virtual apresenta um novo método, uma declaração de método de override restringe um método virtual herdado existente fornecendo uma nova implementação do método.


Um abstract method é um metodo virtual sem implementacao.
O metodo abstract é declarado com o modificador abstract e é permitido apenas uma classe, que tambem é declarada abstrata.
Um método abstrato deve ser override(substituido) em todas as classes derivadas não abstratas.

O exemplo a seguir, delcara uma classe abstract, "Expression", que representa a expressao TREE NODE, e sao derivadas de 3 classes, (constant, VarialbeReference e Operation), que implementam nós de árvore de expressão para operações aritméticas, referências de variável e constantes. (Este exemplo é semelhante, mas não deve ser confundido com os tipos de árvore de expressão).

using System;
using System.Collections.Generic;
public abstract class Expression
{
    public abstract double Evaluate(Dictionary<string,object> vars);
}
public class Constant: Expression
{
    double value;
    public Constant(double value)
    {
        this.value = value;
    }
    public override double Evaluate(Dictionary<string,object> vars)
    {
        return value;
    }
}
public class VariableReference: Expression
{
    string name;
    public VariableReference(string name)
    {
        this.name = name;
    }
    public override double Evaluate(Dictionary<string,object> vars)
    {
        object value = vars[name];
        if (value == null)
        {
            throw new Exception("Unknown variable: " + name);
        }
        return Convert.ToDouble(value);
    }
}
public class Operation: Expression
{
    Expression left;
    char op;
    Expression right;
    public Operation(Expression left, char op, Expression right)
    {
        this.left = left;
        this.op = op;
        this.right = right;
    }
    public override double Evaluate(Dictionary<string,object> vars)
    {
        double x = left.Evaluate(vars);
        double y = right.Evaluate(vars);
        switch (op) {
            case '+': return x + y;
            case '-': return x - y;
            case '*': return x * y;
            case '/': return x / y;
        }
        throw new Exception("Unknown operator");
    }
}

As quatro classes anteriores podem ser usadas para modelar expressões aritméticas. Por exemplo, usando instâncias dessas classes, a expressão x + 3 pode ser representada da seguinte maneira.

Expression e = new Operation(
    new VariableReference("x"),
    '+',
    new Constant(3)
);

O método Evaluate de uma instância Expression é chamado para avaliar a expressão especificada e produzir um valor double. O método recebe um argumento Dictionary que contém nomes de variáveis (como chaves das entradas) e valores (como valores das entradas). Como Evaluate é um método abstrato, classes não abstratas derivadas de Expression devem substituir Evaluate.

Uma implementação de Evaluate do Constant retorna apenas a constante armazenada. Uma implementação de VariableReference consulta o nome de variável no dicionário e retorna o valor resultante. Uma implementação de Operation primeiro avalia os operandos esquerdo e direito (chamando recursivamente seus métodos Evaluate) e, em seguida, executa a operação aritmética determinada.

O seguinte programa usa as classes Expression para avaliar a expressão x * (y + 2) para valores diferentes de x e y.

using System;
using System.Collections.Generic;
class InheritanceExample
{
    public static void ExampleUsage()
    {
        Expression e = new Operation(
            new VariableReference("x"),
            '*',
            new Operation(
                new VariableReference("y"),
                '+',
                new Constant(2)
            )
        );
        Dictionary<string,object> vars = new Dictionary<string, object>();
        vars["x"] = 3;
        vars["y"] = 5;
        Console.WriteLine(e.Evaluate(vars));		// Outputs "21"
        vars["x"] = 1.5;
        vars["y"] = 9;
        Console.WriteLine(e.Evaluate(vars));		// Outputs "16.5"
    }
}

-------------------**********************----------------------

METHOD OVERLOADING

A sobrecarga de método permite que vários métodos na mesma classe tenham o mesmo nome, contanto que tenham assinaturas exclusivas. Ao compilar uma invocação de um método sobrecarregado, o compilador usa a resolução de sobrecarga para determinar o método específico para invocar. A resolução de sobrecarga localizará o método que melhor corresponde aos argumentos ou relatará um erro se nenhuma correspondência for encontrada. O exemplo a seguir mostra a resolução de sobrecarga em vigor. O comentário de cada UsageExample invocação no método mostra qual método é invocado

using System;
class OverloadingExample
{
    static void F()
    {
        Console.WriteLine("F()");
    }
    static void F(object x)
    {
        Console.WriteLine("F(object)");
    }
    static void F(int x)
    {
        Console.WriteLine("F(int)");
    }
    static void F(double x)
    {
        Console.WriteLine("F(double)");
    }
    static void F<T>(T x)
    {
        Console.WriteLine("F<T>(T)");
    }
    static void F(double x, double y)
    {
        Console.WriteLine("F(double, double)");
    }
    public static void UsageExample()
    {
        F();            // Invokes F()
        F(1);           // Invokes F(int)
        F(1.0);         // Invokes F(double)
        F("abc");       // Invokes F<string>(string)
        F((double)1);   // Invokes F(double)
        F((object)1);   // Invokes F(object)
        F<int>(1);      // Invokes F<int>(int)
        F(1, 1);        // Invokes F(double, double)
    }
}



-------------------**********************----------------------

OThER FUNCTION MEMBERS

Os membros que contêm código executável são conhecidos coletivamente como funciton members de uma classe
A seção anterior descreve métodos, que são os principais tipos de membros da função. Esta seção descreve os outros tipos de membros da função com suporte do C#:
Constructors, properties, indexers, events, operators and finalizers.

O exemplo a seguir mostra uma classe generica chamada "MyList<T>" que implementa uma lista de objetos growable. A classe contêm varios exemplos comuns de function member.

OBS: Este exemplo cria uma classe MyList, que não é igual ao .NET padrão System.Collections.Generic.List<T>. Ele ilustra os conceitos necessários para esse tour, mas não serve como substituto para essa classe.

public class MyList<T>
{
    // Constant
    const int defaultCapacity = 4;

    // Fields
    T[] items;
    int count;

    // Constructor
    public MyList(int capacity = defaultCapacity)
    {
        items = new T[capacity];
    }

    // Properties
    public int Count => count;

    public int Capacity
    {
        get { return items.Length; }
        set
        {
            if (value < count) value = count;
            if (value != items.Length)
            {
                T[] newItems = new T[value];
                Array.Copy(items, 0, newItems, 0, count);
                items = newItems;
            }
        }
    }

    // Indexer
    public T this[int index]
    {
        get
        {
            return items[index];
        }
        set
        {
            items[index] = value;
            OnChanged();
        }
    }

    // Methods
    public void Add(T item)
    {
        if (count == Capacity) Capacity = count * 2;
        items[count] = item;
        count++;
        OnChanged();
    }
    protected virtual void OnChanged() =>
        Changed?.Invoke(this, EventArgs.Empty);

    public override bool Equals(object other) =>
        Equals(this, other as MyList<T>);

    static bool Equals(MyList<T> a, MyList<T> b)
    {
        if (Object.ReferenceEquals(a, null)) return Object.ReferenceEquals(b, null);
        if (Object.ReferenceEquals(b, null) || a.count != b.count)
            return false;
        for (int i = 0; i < a.count; i++)
        {
            if (!object.Equals(a.items[i], b.items[i]))
            {
                return false;
            }
        }
    return true;
    }

    // Event
    public event EventHandler Changed;

    // Operators
    public static bool operator ==(MyList<T> a, MyList<T> b) =>
        Equals(a, b);

    public static bool operator !=(MyList<T> a, MyList<T> b) =>
        !Equals(a, b);
}

